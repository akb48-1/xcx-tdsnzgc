{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var natives = process.binding('natives')\nvar module = require('module')\nvar normalRequire = require\nexports.source = src\nexports.require = req\nvar vm = require('vm')\n\n// fallback for 0.x support\nvar runInThisContext, ContextifyScript, Script\n/*istanbul ignore next*/\ntry {\n  ContextifyScript = process.binding('contextify').ContextifyScript;\n  /*istanbul ignore next*/\n  if (process.version.split('.')[0].length > 2) {  // v10.0.0 and above\n    runInThisContext = vm.runInThisContext;\n  } else {\n    runInThisContext = function runInThisContext(code, options) {\n      var script = new ContextifyScript(code, options);\n      return script.runInThisContext();\n    }\n  }\n} catch (er) {\n  Script = process.binding('evals').NodeScript;\n  runInThisContext = Script.runInThisContext;\n}\n\nvar wrap = [\n  '(function (internalBinding) {' +\n    ' return function (exports, require, module, __filename, __dirname) { ',\n  '\\n  };\\n});'\n];\n\n\n// Basically the same functionality as node's (buried deep)\n// NativeModule class, but without caching, or internal/ blocking,\n// or a class, since that's not really necessary.  I assume that if\n// you're loading something with this module, it's because you WANT\n// a separate copy.  However, to preserve semantics, any require()\n// calls made throughout the internal module load IS cached.\nfunction req (id, whitelist) {\n  var cache = Object.create(null)\n\n  if (Array.isArray(whitelist)) {\n    // a whitelist of things to pull from the \"actual\" native modules\n    whitelist.forEach(function (id) {\n      cache[id] = {\n        loading: false,\n        loaded: true,\n        filename: id + '.js',\n        exports: require(id)\n      }\n    })\n  }\n\n  return req_(id, cache)\n}\n\nfunction req_ (id, cache) {\n  // Buffer is special, because it's a type rather than a \"normal\"\n  // class, and many things depend on `Buffer.isBuffer` working.\n  if (id === 'buffer') {\n    return require('buffer')\n  }\n\n  // native_module isn't actually a natives binding.\n  // weird, right?\n  if (id === 'native_module') {\n    return {\n      getSource: src,\n      wrap: function (script) {\n        return wrap[0] + script + wrap[1]\n      },\n      wrapper: wrap,\n      _cache: cache,\n      _source: natives,\n      nonInternalExists: function (id) {\n        return id.indexOf('internal/') !== 0;\n      }\n    }\n  }\n\n  var source = src(id)\n  if (!source) {\n    return undefined\n  }\n  source = wrap[0] + source + wrap[1]\n\n  var internalBinding = function(name) {\n    if (name === 'types') {\n      return process.binding('util');\n    } else {\n      try {\n        return process.binding(name);\n      } catch (e) {}\n      return {};\n    }\n  }\n\n  var cachingRequire = function require (id) {\n    if (cache[id]) {\n      return cache[id].exports\n    }\n    if (id === 'internal/bootstrap/loaders' || id === 'internal/process') {\n      // Provide just enough to keep `graceful-fs@3` working and tests passing.\n      // For now.\n      return {\n        internalBinding: internalBinding,\n        NativeModule: {\n          _source: process.binding('natives'),\n          nonInternalExists: function(id) {\n            return !id.startsWith('internal/');\n          }\n        }\n      };\n    }\n    return req_(id, cache)\n  }\n\n  var nm = {\n    exports: {},\n    loading: true,\n    loaded: false,\n    filename: id + '.js'\n  }\n  cache[id] = nm\n  var fn\n  var setV8Flags = false\n  try {\n    require('v8').setFlagsFromString('--allow_natives_syntax')\n    setV8Flags = true\n  } catch (e) {}\n  try {\n    /* istanbul ignore else */\n    if (ContextifyScript) {\n      fn = runInThisContext(source, {\n        filename: nm.filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n    } else {\n      fn = runInThisContext(source, nm.filename, true);\n    }\n    fn(internalBinding)(nm.exports, cachingRequire, nm, nm.filename, '<no dirname available>')\n    nm.loaded = true\n  } finally {\n    nm.loading = false\n    /*istanbul ignore next*/\n    if (setV8Flags) {\n      // Ref: https://github.com/nodejs/node/blob/591a24b819d53a555463b1cbf9290a6d8bcc1bcb/lib/internal/bootstrap_node.js#L429-L434\n      var re = /^--allow[-_]natives[-_]syntax$/\n      if (!process.execArgv.some(function (s) { return re.test(s) }))\n        require('v8').setFlagsFromString('--noallow_natives_syntax')\n    }\n  }\n\n  return nm.exports\n}\n\nfunction src (id) {\n  return natives[id]\n}\n"]}