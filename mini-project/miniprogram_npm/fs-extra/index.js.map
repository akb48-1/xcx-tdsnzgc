{"version":3,"sources":["index.js","json.js","mkdir.js","copy.js","_copy.js","create.js","remove.js","move.js","output.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AELA,ADGA,AENA,ALeA,ACHA,ACHA;AELA,ADGA,AENA,ALeA,ACHA,ACHA;AELA,ADGA,AENA,ALeA,ACHA,ACHA;AELA,ADGA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ADGA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ADGA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ADGA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA,AFMA;AFOA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,ACHA,ACHA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AENA,ALeA,AENA,AKfA,ACHA;AJaA,ADGA,AHSA,AENA,AKfA,ACHA;AJaA,ADGA,AHSA,AENA,AKfA,ACHA;AJaA,ADGA,AHSA,AENA,AKfA,ACHA;AJaA,ADGA,AHSA,AENA,AKfA,ACHA;AJaA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,AHSA,AENA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,ADGA,ADGA,AKfA;AHUA,AFMA,AKfA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var jsonFile = require('jsonfile')\nvar json = require('./json')\n\nvar fse = {}\nvar fs = require(\"graceful-fs\")\n\n//attach fs methods to fse\nObject.keys(fs).forEach(function(key) {\n  var func = fs[key]\n  if (typeof func == 'function')\n    fse[key] = func\n})\nfs = fse\n\nvar copy = require('./copy')\nfs.copy = copy.copy\nfs.copySync = copy.copySync\n\nvar remove = require('./remove')\nfs.remove = remove.remove\nfs.removeSync = remove.removeSync\nfs['delete'] = fs.remove\nfs.deleteSync = fs.removeSync\n\nvar mkdir = require('./mkdir')\nfs.mkdirs = mkdir.mkdirs\nfs.mkdirsSync = mkdir.mkdirsSync\nfs.mkdirp = fs.mkdirs\nfs.mkdirpSync = fs.mkdirsSync\n\nvar create = require('./create')\nfs.createFile = create.createFile\nfs.createFileSync = create.createFileSync\n\nfs.ensureFile = create.createFile\nfs.ensureFileSync = create.createFileSync\nfs.ensureDir = mkdir.mkdirs\nfs.ensureDirSync = mkdir.mkdirsSync\n\n\nvar move = require('./move')\nfs.move = function(src, dest, opts, callback) {\n  if (typeof opts == 'function') {\n    callback = opts\n    opts = {}\n  }\n\n  if (opts.mkdirp == null) opts.mkdirp = true\n  if (opts.clobber == null) opts.clobber = false\n\n  move(src, dest, opts, callback)\n}\n\n\nvar output = require('./output')\nfs.outputFile = output.outputFile\nfs.outputFileSync = output.outputFileSync\n\n\nfs.readJsonFile = jsonFile.readFile\nfs.readJSONFile = jsonFile.readFile\nfs.readJsonFileSync = jsonFile.readFileSync\nfs.readJSONFileSync = jsonFile.readFileSync\n\nfs.readJson = jsonFile.readFile\nfs.readJSON = jsonFile.readFile\nfs.readJsonSync = jsonFile.readFileSync\nfs.readJSONSync = jsonFile.readFileSync\n\nfs.outputJsonSync = json.outputJsonSync\nfs.outputJSONSync = json.outputJsonSync\nfs.outputJson = json.outputJson\nfs.outputJSON = json.outputJson\n\nfs.writeJsonFile = jsonFile.writeFile\nfs.writeJSONFile = jsonFile.writeFile\nfs.writeJsonFileSync = jsonFile.writeFileSync\nfs.writeJSONFileSync = jsonFile.writeFileSync\n\nfs.writeJson = jsonFile.writeFile\nfs.writeJSON = jsonFile.writeFile\nfs.writeJsonSync = jsonFile.writeFileSync\nfs.writeJSONSync = jsonFile.writeFileSync\n\n\nmodule.exports = fs\n\njsonFile.spaces = 2 //set to 2\nmodule.exports.jsonfile = jsonFile //so users of fs-extra can modify jsonFile.spaces\n\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar jsonFile = require('jsonfile')\nvar mkdir = require('./mkdir')\n\nfunction outputJsonSync(file, data) {\n  var dir = path.dirname(file)\n\n  if (!fs.existsSync(dir))\n    mkdir.mkdirsSync(dir)\n\n  jsonFile.writeFileSync(file, data)\n}\n\nfunction outputJson(file, data, callback) {\n  var dir = path.dirname(file)\n\n  fs.exists(dir, function(itDoes) {\n    if (itDoes) return jsonFile.writeFile(file, data, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n      jsonFile.writeFile(file, data, callback)\n    })\n  })\n}\n\nmodule.exports = {\n  outputJsonSync: outputJsonSync,\n  outputJson: outputJson\n}\n","var fs = require('graceful-fs')\nvar path = require('path')\n\nvar octal_0777 = parseInt('0777', 8)\n\nfunction mkdirs(p, opts, f, made) {\n  if (typeof opts === 'function') {\n    f = opts\n    opts = {}\n  }\n  else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  var mode = opts.mode\n  var xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = octal_0777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  var cb = f || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, function (er) {\n    if (!er) {\n      made = made || p\n      return cb(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) == p) return cb(er)\n        mkdirs(path.dirname(p), opts, function (er, made) {\n          if (er) cb(er, made)\n          else mkdirs(p, opts, cb, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, function (er2, stat) {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) cb(er, made)\n          else cb(null, made)\n        })\n        break\n    }\n  })\n}\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  var mode = opts.mode\n  var xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = octal_0777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  }\n  catch (err0) {\n    switch (err0.code) {\n      case 'ENOENT' :\n        made = mkdirsSync(path.dirname(p), opts, made)\n        mkdirsSync(p, opts, made)\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        var stat\n        try {\n          stat = xfs.statSync(p)\n        }\n        catch (err1) {\n          throw err0\n        }\n        if (!stat.isDirectory()) throw err0\n        break\n    }\n  }\n\n  return made\n}\n\nmodule.exports = {\n  mkdirs: mkdirs,\n  mkdirsSync: mkdirsSync\n}\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar ncp = require('./_copy').ncp\nvar mkdir = require('./mkdir')\nvar create = require('./create')\n\nvar BUF_LENGTH = 64 * 1024\nvar _buff = new Buffer(BUF_LENGTH)\n\nvar copyFileSync = function(srcFile, destFile) {\n  var fdr = fs.openSync(srcFile, 'r')\n  var stat = fs.fstatSync(fdr)\n  var fdw = fs.openSync(destFile, 'w', stat.mode)\n  var bytesRead = 1\n  var pos = 0\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction copy(src, dest, options, callback) {\n  if( typeof options == \"function\" && !callback) {\n    callback = options\n    options = {}\n  } else if (typeof options == \"function\" || options instanceof RegExp) {\n    options = {filter: options}\n  }\n  callback = callback || function(){}\n\n  fs.lstat(src, function(err, stats) {\n    if (err) return callback(err)\n\n    var dir = null\n    if (stats.isDirectory()) {\n      var parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, function(dirExists) {\n      if (dirExists) return ncp(src, dest, options, callback)\n      mkdir.mkdirs(dir, function(err) {\n        if (err) return callback(err)\n        ncp(src, dest, options, callback)\n      })\n    })\n  })\n}\n\nfunction copySync(src, dest, options) {\n  if (typeof options == \"function\" || options instanceof RegExp) {\n    options = {filter: options}\n  }\n\n  options = options || {}\n  options.recursive = !!options.recursive\n\n  options.filter = options.filter || function() { return true }\n\n  var stats = options.recursive ? fs.lstatSync(src) : fs.statSync(src)\n  var destFolder = path.dirname(dest)\n  var destFolderExists = fs.existsSync(destFolder)\n  var performCopy = false\n\n  if (stats.isFile()) {\n    if (options.filter instanceof RegExp) performCopy = options.filter.test(src)\n    else if (typeof options.filter == \"function\") performCopy = options.filter(src)\n\n    if (performCopy) {\n      if (!destFolderExists) mkdir.mkdirsSync(destFolder)\n      copyFileSync(src, dest)\n    }\n  }\n  else if (stats.isDirectory()) {\n    if (!fs.existsSync(dest)) mkdir.mkdirsSync(dest)\n    var contents = fs.readdirSync(src)\n    contents.forEach(function(content) {\n      copySync(path.join(src, content), path.join(dest, content), {filter: options.filter, recursive: true})\n    })\n  }\n  else if (options.recursive && stats.isSymbolicLink()) {\n    var srcPath = fs.readlinkSync(src)\n    fs.symlinkSync(srcPath, dest)\n  }\n}\n\nmodule.exports = {\n  copy: copy,\n  copySync: copySync\n}\n\n","// imported from ncp (this is temporary, will rewrite)\n\nvar fs = require('graceful-fs')\nvar path = require('path')\n\nfunction ncp (source, dest, options, callback) {\n  var cback = callback\n\n  if (!callback) {\n    cback = options\n    options = {}\n  }\n\n  var basePath = process.cwd()\n  var currentPath = path.resolve(basePath, source)\n  var targetPath = path.resolve(basePath, dest)\n\n  var filter = options.filter\n  var transform = options.transform\n  var clobber = options.clobber !== false\n  var dereference = options.dereference\n\n  var errs = null\n  \n  var started = 0\n  var finished = 0\n  var running = 0\n  // this is pretty useless now that we're using graceful-fs\n  // consider removing\n  var limit = options.limit || 512\n\n  startCopy(currentPath)\n  \n  function startCopy(source) {\n    started++\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return cb(true)\n        }\n      }\n      else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return cb(true)\n        }\n      }\n    }\n    return getStats(source)\n  }\n\n  function getStats(source) {\n    var defer = global.setImmediate || process.nextTick\n    var stat = dereference ? fs.stat : fs.lstat\n    if (running >= limit) {\n      return defer(function () {\n        getStats(source)\n      })\n    }\n    running++\n    stat(source, function (err, stats) {\n      var item = {}\n      if (err) {\n        return onError(err)\n      }\n\n      // We need to get the mode from the stats object and preserve it.\n      item.name = source\n      item.mode = stats.mode\n      item.mtime = stats.mtime //modified time\n      item.atime = stats.atime //access time\n\n      if (stats.isDirectory()) {\n        return onDir(item)\n      }\n      else if (stats.isFile()) {\n        return onFile(item)\n      }\n      else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source)\n      }\n    })\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath)\n    isWritable(target, function (writable) {\n      if (writable) {\n        copyFile(file, target)\n      } else {\n        if(clobber) {\n          rmFile(target, function () {\n            copyFile(file, target)\n          })\n        } else {\n          cb()\n        }\n      }\n    })\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name),\n        writeStream = fs.createWriteStream(target, { mode: file.mode })\n    \n    readStream.on('error', onError)\n    writeStream.on('error', onError)\n    \n    if(transform) {\n      transform(readStream, writeStream, file)\n    } else {\n      writeStream.on('open', function() {\n        readStream.pipe(writeStream)\n      })\n    }\n\n    //presumably old node then\n    var eventName = global.setImmediate ? 'finish' : 'close'\n    writeStream.once(eventName, function() {\n      cb()\n    })\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) {\n        return onError(err)\n      }\n      return done()\n    })\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath)\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target)\n      }\n      copyDir(dir.name)\n    })\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) {\n        return onError(err)\n      }\n      copyDir(dir.name)\n    })\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) {\n        return onError(err)\n      }\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item))\n      })\n      return cb()\n    })\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath)\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) {\n        return onError(err)\n      }\n      checkLink(resolvedPath, target)\n    })\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath)\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target)\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) {\n          return onError(err)\n        }\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest)\n        }\n        if (targetDest === resolvedPath) {\n          return cb()\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target)\n        })\n      })\n    })\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) {\n        return onError(err)\n      }\n      return cb()\n    })\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true)\n        return done(false)\n      }\n      return done(false)\n    })\n  }\n\n  function onError(err) {\n    if (options.stopOnError) {\n      return cback(err)\n    }\n    else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs)\n    }\n    else if (!errs) {\n      errs = []\n    }\n    if (typeof errs.write === 'undefined') {\n      errs.push(err)\n    }\n    else { \n      errs.write(err.stack + '\\n\\n')\n    }\n    return cb()\n  }\n\n  function cb(skipped) {\n    if (!skipped) running--\n    finished++\n    if ((started === finished) && (running === 0)) {\n      if (cback !== undefined ) {\n        return errs ? cback(errs) : cback(null)\n      }\n    }\n  }\n}\n\n// todo, make this just export ncp\nmodule.exports.ncp = ncp\n\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar mkdir = require('./mkdir')\n\nfunction createFile (file, callback) {\n  function makeFile() {\n    fs.writeFile(file, '', function(err) {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.exists(file, function(fileExists) {\n    if (fileExists) return callback()\n    var dir = path.dirname(file)\n    fs.exists(dir, function(dirExists) {\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, function(err) {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  if (fs.existsSync(file)) return\n\n  var dir = path.dirname(file)\n  if (!fs.existsSync(dir))\n    mkdir.mkdirsSync(dir)\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: createFile,\n  createFileSync: createFileSync\n}\n","var rimraf = require('rimraf')\n\nfunction removeSync(dir) {\n  return rimraf.sync(dir)\n}\n\nfunction remove(dir, callback) {\n  return callback ? rimraf(dir, callback) : rimraf(dir, function(){})\n}\n\nmodule.exports = {\n  remove: remove,\n  removeSync: removeSync\n}\n","// most of this code was written by Andrew Kelley\n// licensed under the BSD license: see\n// https://github.com/andrewrk/node-mv/blob/master/package.json\n\n// this needs a cleanup\n\nvar fs = require('graceful-fs')\nvar ncp = require('./_copy').ncp\nvar path = require('path')\nvar rimraf = require('rimraf')\nvar mkdirp = require('./mkdir').mkdirs\n\nfunction mv(source, dest, options, callback){\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  var shouldMkdirp = !!options.mkdirp\n  var clobber = options.clobber !== false\n  var limit = options.limit || 16\n\n  if (shouldMkdirp) {\n    mkdirs()\n  } else {\n    doRename()\n  }\n\n  function mkdirs() {\n    mkdirp(path.dirname(dest), function(err) {\n      if (err) return callback(err)\n      doRename()\n    })\n  }\n\n  function doRename() {\n    if (clobber) {\n      fs.rename(source, dest, function(err) {\n        if (!err) return callback()\n\n        if (err.code === 'ENOTEMPTY') {\n          rimraf(dest, function(err) {\n            if (err) return callback(err)\n            options.clobber = false // just clobbered it, no need to do it again\n            mv(source, dest, options, callback)\n          })\n          return\n        }\n\n        if (err.code !== 'EXDEV') return callback(err)\n        moveFileAcrossDevice(source, dest, clobber, limit, callback)\n      })\n    } else {\n      fs.link(source, dest, function(err) {\n        if (err) {\n          if (err.code === 'EXDEV') {\n            moveFileAcrossDevice(source, dest, clobber, limit, callback)\n            return\n          }\n          if (err.code === 'EISDIR' || err.code === 'EPERM') {\n            moveDirAcrossDevice(source, dest, clobber, limit, callback)\n            return\n          }\n          callback(err)\n          return\n        }\n        fs.unlink(source, callback)\n      })\n    }\n  }\n}\n\nfunction moveFileAcrossDevice(source, dest, clobber, limit, callback) {\n  var outFlags = clobber ? 'w' : 'wx'\n  var ins = fs.createReadStream(source)\n  var outs = fs.createWriteStream(dest, {flags: outFlags})\n\n  ins.on('error', function(err) {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n\n    // may want to create a directory but `out` line above\n    // creates an empty file for us: See #108\n    // don't care about error here\n    fs.unlink(dest, function() {\n      // note: `err` here is from the input stream errror\n      if (err.code === 'EISDIR' || err.code === 'EPERM') {\n        moveDirAcrossDevice(source, dest, clobber, limit, callback)\n      } else {\n        callback(err)\n      }\n    })\n  })\n\n  outs.on('error', function(err) {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n    callback(err)\n  })\n\n  outs.once('close', onClose)\n  ins.pipe(outs)\n\n  function onClose() {\n    fs.unlink(source, callback)\n  }\n}\n\nfunction moveDirAcrossDevice(source, dest, clobber, limit, callback) {\n  var options = {\n    stopOnErr: true,\n    clobber: false,\n    limit: limit,\n  }\n\n  function startNcp() {\n    ncp(source, dest, options, function(errList) {\n      if (errList) return callback(errList[0])\n      rimraf(source, callback)\n    })\n  }\n\n  if (clobber) {\n    rimraf(dest, function(err) {\n      if (err) return callback(err)\n      startNcp()\n    })\n  } else {\n    startNcp()\n  }\n}\n\nmodule.exports = mv\n\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar mkdir = require('./mkdir')\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  var dir = path.dirname(file)\n  fs.exists(dir, function(itDoes) {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n    \n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n      \n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, data, encoding) {\n  var dir = path.dirname(file)\n  if (fs.existsSync(dir)) \n    return fs.writeFileSync.apply(fs, arguments)\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\nmodule.exports = {\n  outputFile: outputFile,\n  outputFileSync: outputFileSync\n}\n"]}