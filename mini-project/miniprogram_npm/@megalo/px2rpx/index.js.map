{"version":3,"sources":["index.js","lib\\px2rpx.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib/px2rpx');\n","\n\nvar css = require('css');\nvar extend = require('extend');\n\nvar defaultConfig = {\n  rpxUnit: 1,            // rpx unit value (default: 1)\n  rpxPrecision: 6,        // rpx value precision (default: 6)\n  keepComment: 'no'       // no transform value comment (default: `no`)\n};\n\nvar pxRegExp = /\\b(\\d+(\\.\\d+)?)px\\b/;\n\nfunction Px2rpx(options) {\n  this.config = {};\n  extend(this.config, defaultConfig, options);\n}\n\n// generate rpx version stylesheet\nPx2rpx.prototype.generateRpx = function (cssText) {\n  var self = this;\n  var config = self.config;\n  var astObj = css.parse(cssText);\n\n  function processRules(rules) { // FIXME: keyframes do not support `force px` comment\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      if (rule.type === 'media') {\n        processRules(rule.rules); // recursive invocation while dealing with media queries\n        continue;\n      } else if (rule.type === 'keyframes') {\n        processRules(rule.keyframes); // recursive invocation while dealing with keyframes\n        continue;\n      } else if (rule.type !== 'rule' && rule.type !== 'keyframe') {\n        continue;\n      }\n\n      var declarations = rule.declarations;\n      for (var j = 0; j < declarations.length; j++) {\n        var declaration = declarations[j];\n        // need transform: declaration && has 'px'\n        if (declaration.type === 'declaration' && pxRegExp.test(declaration.value)) {\n          var nextDeclaration = declarations[j + 1];\n          if (nextDeclaration && nextDeclaration.type === 'comment') { // next next declaration is comment\n            if (nextDeclaration.comment.trim() === config.keepComment) { // no transform\n              declarations.splice(j + 1, 1); // delete corresponding comment\n              continue;\n            } else {\n              declaration.value = self._getCalcValue('rpx', declaration.value); // common transform\n            }\n          } else {\n            declaration.value = self._getCalcValue('rpx', declaration.value); // common transform\n          }\n        }\n      }\n\n      // if the origin rule has no declarations, delete it\n      if (!rules[i].declarations.length) {\n        rules.splice(i, 1);\n        i--;\n      }\n    }\n  }\n\n  processRules(astObj.stylesheet.rules);\n\n  return css.stringify(astObj);\n};\n\n// get calculated value of px or rpx\nPx2rpx.prototype._getCalcValue = function (type, value) {\n  var config = this.config;\n  var pxGlobalRegExp = new RegExp(pxRegExp.source, 'g');\n\n  function getValue(val) {\n    val = parseFloat(val.toFixed(config.rpxPrecision)); // control decimal precision of the calculated value\n    return val == 0 ? val : val + type;\n  }\n\n  return value.replace(pxGlobalRegExp, function ($0, $1) {\n    return getValue($1 / config.rpxUnit);\n  });\n};\n\nmodule.exports = Px2rpx;\n"]}